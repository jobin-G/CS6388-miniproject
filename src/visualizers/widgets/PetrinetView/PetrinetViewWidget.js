/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Apr 23 2021 18:59:49 GMT-0400 (Eastern Daylight Time).
 */

define(['jointjs',
        'css!./styles/PetrinetViewWidget.css'], function (joint) {
        'use strict';

    var WIDGET_CLASS = 'petrinet-view';

    function PetrinetViewWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    PetrinetViewWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;


        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._initialState;

        this._jointSM = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
            el: this._el,
            width : width,
            height: height,
            model: this._jointSM,
            interactive: false
        });

        // Create a dummy header
        this._el.append('<');

        // add event calls to elements
        this._jointPaper.on('element:pointerdblclick', function(elementView) {
            const currentElement = elementView.model;

            //If a transition is clicked...
            if(currentElement.attributes.type == "standard.Rectangle"){
                let sm = self._webgmeSM;
                let transition_path = sm.id2path[currentElement.id];
                let transition_src = [];
                let transition_dst = [];
                
                //Loop through all arcs to find the Places the Transition is src-ed from and dst-ed to
                Object.keys(sm.Arcs).forEach(arc => {
                    let a = sm.Arcs[arc];
                    
                    if(a.dst == transition_path){
                        transition_src.push(a.src);
                    };

                    if(a.src == transition_path){
                        transition_dst.push(a.dst);
                    };
                });
                
                //If any src has an available token, decrement it and increment the first dst
                for (let i = 0; i < transition_src.length; i++) {
                    let src = transition_src[i];
                    console.log(src);
                    if(sm.Places[src].tokens > 0){
                        sm.Places[src].tokens= sm.Places[src].tokens-1;

                        let dst = transition_dst.pop();
                        sm.Places[dst].tokens = sm.Places[dst].tokens+1;
                        break;
                    }
                }
                // transition_src.every(src => {
                //     console.log(src);
                //     if(sm.Places[src].tokens > 0){
                //         sm.Places[src].tokens= sm.Places[src].tokens-1;

                //         let dst = transition_dst.pop();
                //         sm.Places[dst].tokens = sm.Places[dst].tokens+1;
                //         return;
                //     }   
                // });
                self._decorateMachine();
            }
        });
        this._webgmeSM = null;
    };

    PetrinetViewWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    // State Machine manipulating functions called from the controller
    PetrinetViewWidget.prototype.initMachine = function (machineDescriptor) {
        const self = this;
        self._webgmeSM = machineDescriptor;
        self._webgmeSM.current = self._webgmeSM.init;
        self._jointSM.clear();
        let sm = self._webgmeSM;
        sm.id2path = {};
        sm.path2id = {};

        Object.keys(sm).forEach(nodeType => {

            let nt = sm[nodeType];
            
            //Logic for adding Place nodes into Visualization
            if(nodeType == 'Places'){
                Object.keys(nt).forEach(ntDetails => {
                    let nodeDetails = (nt[ntDetails]);
                    let tokens = nodeDetails.tokens;
                    let tokenSVGArray =[];

                    //This for loop builds the token portion of the Place SVG
                    for (i = 1; i <= tokens; i += 1) {
                        tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
                         }
                    let placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="none" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'

                    var vertex = new joint.shapes.basic.Image({
                        markup: placeSVG,      
                      });
                    
                    //Place the SVG in the same position as the META node
                    vertex.position(nodeDetails.x, nodeDetails.y)
            
                    //Add SVG to graph
                    vertex.addTo(self._jointSM);

                    sm.Places[ntDetails].joint = vertex;
                    sm.id2path[vertex.id] = ntDetails;
                    sm.path2id[ntDetails] = vertex.id;
                });
            }

            //Logic for adding Transition nodes into Visualization
            if(nodeType == 'Transitions'){
                Object.keys(nt).forEach(ntDetails => {
                    let nodeDetails = (nt[ntDetails]);

                    let vertex = new joint.shapes.standard.Rectangle();

                    vertex.position(nodeDetails.x, nodeDetails.y)
            
                    vertex.resize(30, 100);

                    vertex.attr({
                        body: {
                            fill: 'black'}});

                    vertex.addTo(self._jointSM);

                    sm.Transitions[ntDetails].joint = vertex;
                    sm.id2path[vertex.id] = ntDetails;
                    sm.path2id[ntDetails] = vertex.id;
                });
            }            
            
        //Logic for adding Links between Places and Transitions into Visualization
        if(nodeType == 'Arcs'){
            Object.keys(nt).forEach(ntDetails => {
                let nodeDetails = (nt[ntDetails]);
                let src = nodeDetails.src;
                let dst = nodeDetails.dst;

                const link = new joint.shapes.standard.Link({
                    source: {id: sm.path2id[src]},
                    target: {id: sm.path2id[dst]},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    }
                });

                link.addTo(self._jointSM);
            });
        }
    });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decorateMachine();
    };

    PetrinetViewWidget.prototype.destroyMachine = function () {

    };

    PetrinetViewWidget.prototype.fireEvent = function (event) {
        const self = this;

    };

    PetrinetViewWidget.prototype.resetMachine = function () {
        this._webgmeSM.current = this._webgmeSM.init;

        Object.keys(this._webgmeSM.Places).forEach(place => {
            this._webgmeSM.Places[place].tokens = this._webgmeSM.Initial_Places[place].tokens;
        });


        this._decorateMachine();
    };

    PetrinetViewWidget.prototype._decorateMachine = function() {

        //Logic for adding Place nodes into Visualization
        Object.keys(this._webgmeSM.Places).forEach(place => {
            let nodeDetails = (this._webgmeSM.Places[place]);
            let tokens = nodeDetails.tokens;
            let tokenSVGArray =[];
            let placeSVG = " ";

        //This for loop builds the token portion of the Place SVG
        for (i = 1; i <= tokens; i += 1) {
            tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
            }
        
        placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="white" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'
 
        var vertex = new joint.shapes.basic.Image({
            markup: placeSVG,      
            });
                    
        //Place the SVG in the same position as the META node
        vertex.position(nodeDetails.x, nodeDetails.y)
            
        //Add SVG to graph
        vertex.addTo(this._jointSM);

        this._webgmeSM.Places[place].joint = vertex;
        this._webgmeSM.id2path[vertex.id] = place;
        this._webgmeSM.path2id[place] = vertex.id;
        });
    };

    PetrinetViewWidget.prototype._setCurrentState = function(newCurrent) {
        this._webgmeSM.current = newCurrent;
        this._decorateMachine();
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    PetrinetViewWidget.prototype.destroy = function () {
    };

    PetrinetViewWidget.prototype.onActivate = function () {
        this._logger.debug('PetrinetViewWidget has been activated');
    };

    PetrinetViewWidget.prototype.onDeactivate = function () {
        this._logger.debug('PetrinetViewWidget has been deactivated');
    };

    return PetrinetViewWidget;
});
