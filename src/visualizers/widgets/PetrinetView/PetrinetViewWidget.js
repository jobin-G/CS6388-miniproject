/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Apr 23 2021 18:59:49 GMT-0400 (Eastern Daylight Time).
 */

define(['jointjs',
        'css!./styles/PetrinetViewWidget.css'], function (joint) {
        'use strict';

    var WIDGET_CLASS = 'petrinet-view';

    function PetrinetViewWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    PetrinetViewWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._jointSM = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
            el: this._el,
            width : width,
            height: height,
            model: this._jointSM,
            interactive: false
        });

        // Create a dummy header
        this._el.append('<');

        // add event calls to elements
        this._jointPaper.on('element:pointerdblclick', function(elementView) {
            const currentElement = elementView.model;
            

            //If a transition is clicked...
            if(currentElement.attributes.type == "standard.Rectangle"){
                let sm = self._webgmeSM;
                let transition_path = sm.id2path[currentElement.id];
                let transition_src;
                let transition_dst;
                
                //Loop through all arcs to find the Place the Transition is src-ed from and dst-ed to
                Object.keys(sm.Arcs).forEach(arc => {
                    let a = sm.Arcs[arc];
                    
                    if(a.dst == transition_path){
                        transition_src = a.src;
                    };

                    if(a.src == transition_path){
                        transition_dst = a.dst;
                    };
                });

                //If the src has an available token, decrement it and increment the dst
                if(sm.Places[transition_src].tokens > 0){
                    sm.Places[transition_src].tokens= sm.Places[transition_src].tokens-1;
                    sm.Places[transition_dst].tokens = sm.Places[transition_dst].tokens+1;

                    //**** REDUNDANT CODE - Couldn't figure out how to get the SVGs to reload :( */
                    //Logic for adding Place nodes into Visualization
                    Object.keys(sm.Places).forEach(place => {
                        let nodeDetails = (sm.Places[place]);
                        let tokens = nodeDetails.tokens;
                        let tokenSVGArray =[];
                        let placeSVG = " ";
            
                    //This for loop builds the token portion of the Place SVG
                    for (i = 1; i <= tokens; i += 1) {
                        tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
                        }
                    
                    placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="white" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'
             
                    var vertex = new joint.shapes.basic.Image({
                        markup: placeSVG,      
                        });
                                
                    //Place the SVG in the same position as the META node
                    vertex.position(nodeDetails.x, nodeDetails.y)
                        
                    //Add SVG to graph
                    vertex.addTo(self._jointSM);
            
                    sm.Places[place].joint = vertex;
                    sm.id2path[vertex.id] = place;
                    sm.path2id[place] = vertex.id;
                    });
                }
            }
        });
    };

    PetrinetViewWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    // State Machine manipulating functions called from the controller
    PetrinetViewWidget.prototype.initMachine = function (machineDescriptor) {
        const self = this;
        self._webgmeSM = machineDescriptor;
        self._webgmeSM.current = self._webgmeSM.init;
        self._jointSM.clear();
        const sm = self._webgmeSM;
        sm.id2path = {};
        sm.path2id = {};
        

        Object.keys(sm).forEach(nodeType => {

            let nt = sm[nodeType];
            
            //Logic for adding Place nodes into Visualization
            if(nodeType == 'Places'){
                Object.keys(nt).forEach(ntDetails => {
                    let nodeDetails = (nt[ntDetails]);
                    let tokens = nodeDetails.tokens;
                    let tokenSVGArray =[];

                    //This for loop builds the token portion of the Place SVG
                    for (i = 1; i <= tokens; i += 1) {
                        tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
                         }
                    let placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="none" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'

                    var vertex = new joint.shapes.basic.Image({
                        markup: placeSVG,      
                      });
                    
                    //Place the SVG in the same position as the META node
                    vertex.position(nodeDetails.x, nodeDetails.y)
            
                    //Add SVG to graph
                    vertex.addTo(self._jointSM);

                    sm.Places[ntDetails].joint = vertex;
                    sm.id2path[vertex.id] = ntDetails;
                    sm.path2id[ntDetails] = vertex.id;
                });
            }

            //Logic for adding Transition nodes into Visualization
            if(nodeType == 'Transitions'){
                Object.keys(nt).forEach(ntDetails => {
                    let nodeDetails = (nt[ntDetails]);

                    let vertex = new joint.shapes.standard.Rectangle();

                    vertex.position(nodeDetails.x, nodeDetails.y)
            
                    vertex.resize(30, 100);

                    vertex.attr({
                        body: {
                            fill: 'black'}});

                    vertex.addTo(self._jointSM);

                    sm.Transitions[ntDetails].joint = vertex;
                    sm.id2path[vertex.id] = ntDetails;
                    sm.path2id[ntDetails] = vertex.id;
                });
            }            
            
        //Logic for adding Links between Places and Transitions into Visualization
        if(nodeType == 'Arcs'){
            Object.keys(nt).forEach(ntDetails => {
                let nodeDetails = (nt[ntDetails]);
                let src = nodeDetails.src;
                let dst = nodeDetails.dst;

                const link = new joint.shapes.standard.Link({
                    source: {id: sm.path2id[src]},
                    target: {id: sm.path2id[dst]},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    }
                });

                link.addTo(self._jointSM);
            });
        }
    });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decorateMachine();
    };

    PetrinetViewWidget.prototype.destroyMachine = function () {

    };

    PetrinetViewWidget.prototype.fireEvent = function (event) {
        const self = this;
        const current = self._webgmeSM.states[self._webgmeSM.current];
        const link = current.jointNext[event];
        const linkView = link.findView(self._jointPaper);
        linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), {duration:500}, function() {
           self._webgmeSM.current = current.next[event];
           self._decorateMachine();
        });

        paper.on('cell:pointerdblclick', function(cellView) {
            var isElement = cellView.model.isElement();
            var message = (isElement ? 'Element' : 'Link') + ' clicked';
            info.attr('label/text', message);
        
            info.attr('body/visibility', 'visible');
            info.attr('label/visibility', 'visible');
        });


    };

    PetrinetViewWidget.prototype.resetMachine = function () {
        this._webgmeSM.current = this._webgmeSM.init;
        this._decorateMachine();
    };

    PetrinetViewWidget.prototype._decorateMachine = function() {
        const sm = this._webgmeSM.init;
        console.log(sm);

        // Object.keys(sm.Places).forEach(place => {
        //     let nodeDetails = (sm.Places[place]);
        //     let tokens = nodeDetails.tokens;
        //     let tokenSVGArray =[];
        //     let placeSVG = " ";

        // //This for loop builds the token portion of the Place SVG
        // for (i = 1; i <= tokens; i += 1) {
        //     tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
        //     }
        
        // placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="white" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'
 
        // var vertex = new joint.shapes.basic.Image({
        //     markup: placeSVG,      
        //     });
                    
        // //Place the SVG in the same position as the META node
        // vertex.position(nodeDetails.x, nodeDetails.y)
            
        // //Add SVG to graph
        // vertex.addTo(self._jointSM);

        // self._webgmeSM.Places[place].joint = vertex;
        // self._webgmeSM.id2path[vertex.id] = place;
        // self._webgmeSM.path2id[place] = vertex.id;
        // });
    };

    PetrinetViewWidget.prototype._setCurrentState = function(newCurrent) {
        this._webgmeSM.current = newCurrent;
        this._decorateMachine();
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    PetrinetViewWidget.prototype.destroy = function () {
    };

    PetrinetViewWidget.prototype.onActivate = function () {
        this._logger.debug('PetrinetViewWidget has been activated');
    };

    PetrinetViewWidget.prototype.onDeactivate = function () {
        this._logger.debug('PetrinetViewWidget has been deactivated');
    };

    return PetrinetViewWidget;
});
